{"version":3,"sources":["Assets/Icons/source.png","Assets/Icons/destination.png","Assets/Icons/wall.png","Assets/Icons/weight.png","Assets/Icons/unvisited.png","Assets/Icons/visited.png","Assets/Icons/path.png","gridOptions.js","Components/Cell.js","Components/Row.js","Components/Grid.js","Algorithms/searchingAlgorithms.js","Algorithms/mazeAlgorithms.js","Components/ControlPanel.js","Components/App.js","index.js"],"names":["module","exports","gridOptions","disableUserInteraction","document","querySelectorAll","forEach","elem","disabled","enableUserInteraction","animationLaunched","instantAnimationOn","isAnimated","source","destination","isSourceDragged","isDestinationDragged","chozenAlgorithmCallback","a","matrix","delay","clicked","wpressed","sourceDragged","destinationDragged","getSize","this","length","isSource","i","j","isDestination","isUnvisited","includes","class","isWall","isWeighted","weighted","isVisited","isPath","clearPath","row","cell","update","clearBoard","Cell","position","useState","options","setOptions","classList","handleMouseDown","e","button","handleMouseOver","prevSource_i","prevSource_j","prevSourceOptions","prevDestination_i","prevDestination_j","prevDestinationOptions","id","onDragStart","preventDefault","className","onMouseDown","onTouchStart","onMouseOver","onTouchMove","Row","columnCount","Array","fill","map","_","key","Grid","rowCount","startNodePosition","endNodePosition","rows","toString","start_i","start_j","end_i","end_j","handleMouseUp","handleMouseLeave","onMouseUp","onTouchEnd","onMouseLeave","runAlgorithm","name","searchingAlgorithms","ReferenceError","animateCell","state","time","Promise","resolve","setTimeout","bfs","src","dst","mat","n","m","visited","isValid","queue","distance","path","addends","current","shift","x","y","push","newX","newY","dfs","search","has","add","foundPath","Set","dijkstra","unvisited","prev","distances","Infinity","stringify","indexify","vertex","split","idx","Number","extractMin","minDistance","minDistanceVertex","verticies","keys","v","delete","getNeighbors","neighbors","size","neighbor","alt","shortestPath","reverse","astar","openSet","gScore","fScore","getHeruistic","Math","abs","minFScore","minFScoreVertex","tentative_gScore","currentNode","runMazeAlgorithm","mazeAlgorithms","recursiveDivision","randInt","min","max","floor","random","chooseOrientation","height","width","randWallIndex","from","to","wallIndex","indicies","randHoleIndex","holeIndex","col","divide","orientation","sourceNeighbors","filter","every","randIndex","destinationNeighbors","randomizedDFS","getNeigborsWithDistance","shuffled","l","temp","pop","getNeigbors","getHoleNeighbors","wallI","wallJ","holeI","holeJ","holeNeighbors","holeNeighbor","binaryTree","passageJ","passageI","primsRandomizedAlgorithm","middleRow","middleCol","console","log","extractRandomVertexFromUnvisitedSet","randVertex","getVisitedNeigbors","r","c","getWallNeighbors","getUnvisitedNeigbors","vi","vj","visitedNeigbors","ControlPanel","useEffect","getElementById","value","checked","body","addEventListener","wallToggleON","onClick","htmlFor","type","onChange","target","require","App","title","ReactDOM","render"],"mappings":"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","file":"static/js/main.528e58fc.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAA5QAAAOUBj+WbPAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAErSURBVFiF7ZZBSgNBFERfqWQXoqDiMngKl55AdOtCFDyAJ/AcgoLiRSQ7zyAoCAoRJERECKL8LJKRyZ8/o0KcuOiCv6kpeh7dNc1gZmQDLAHPgAFb+Wd/NQtMqgV8AGfAgaR1pquemV3mDQ+Q6RPYHk9eN8CV81aBHee9A+fBunuSOmZ2/+W4I2gDXeCE0TH4ufBbCGwEuX603eO123lvrmQHalMCKCshwC3w4LxHSZvOWwY6zhsEOYBGwako4VFQon2KhbsOcotBLptUwv8FUFXCpqQ15wl4cl4vyDWDHMBKwUk3YQKYNUDVVxBpV5L/R5gPci1J/ZL3vf0U4Bg4/R3ftxqY2QRYFcCrmXWnDFDQzDuQABJAAkgAZQDR/V4LwAuj6/kQuKsDYAjlHSrEjxxhcgAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG0AAABuCAYAAAAtbJ34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAEYSURBVHhe7dHBCcAwAAMxp/vv3ObRJQQnMB7gzrb3LpDn/0CKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigonG2D4DMAdvmC+R4AAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAB4CAYAAAAnrQZhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIVSURBVHhe7dGhcUMBFMTAdJ/u0ohJYNg31xwwjN4IbAX79f3zenJPsUcVe1SxRxV7VLFHFXtUsUcVe1SxR30U+/v35B9ZR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI7oo9j4FHtUsUcVe1SxRxV7VLFHFXtUsUcVe9LreQNncxQk3K89qQAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIsSURBVHhe7dgxUQMAFAVB3KMhpjCSGSwEAWyRDt6fK1bBdffx+fV85a4CH1fg4wp8XIGPK/BxBT6uwMcV+Li3Az8e3/lH1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqN5O3A2VTg4wp8XIGPK/BxBT6uwMcV+LgCH1fg494OrF2Wv6NGvz1fP6xss6BalwdDAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAABtCAYAAABAz1RVAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAEUSURBVHhe7dExDQAwDMCwbvw5d89IRLKfAMjZnR1y7i8xxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2Vc0swD6O0D1yemuPIAAAAASUVORK5CYII=\"","const gridOptions = {\r\n  disableUserInteraction: function () {\r\n    document\r\n      .querySelectorAll('#controlPanel button')\r\n      .forEach((elem) => (elem.disabled = true));\r\n  },\r\n  enableUserInteraction: function () {\r\n    document\r\n      .querySelectorAll('#controlPanel button')\r\n      .forEach((elem) => (elem.disabled = false));\r\n  },\r\n  animationLaunched: false,\r\n  instantAnimationOn: true,\r\n  isAnimated: true,\r\n  source: [],\r\n  destination: [],\r\n  isSourceDragged: false,\r\n  isDestinationDragged: false,\r\n  chozenAlgorithmCallback: async () => {},\r\n  matrix: null,\r\n  delay: 0,\r\n  clicked: false,\r\n  wpressed: false,\r\n  sourceDragged: false,\r\n  destinationDragged: false,\r\n  getSize: function () {\r\n    return [this.matrix.length, this.matrix[0].length];\r\n  },\r\n  isSource: function (i, j) {\r\n    return this.matrix[i][j].isSource;\r\n  },\r\n  isDestination: function (i, j) {\r\n    return this.matrix[i][j].isDestination;\r\n  },\r\n  isUnvisited: function (i, j) {\r\n    return ['unvisited', 'unvisited-animated'].includes(\r\n      this.matrix[i][j].class\r\n    );\r\n  },\r\n\r\n  isWall: function (i, j) {\r\n    return ['wall', 'wall-animated'].includes(this.matrix[i][j].class);\r\n  },\r\n  isWeighted: function (i, j) {\r\n    return this.matrix[i][j].weighted;\r\n  },\r\n  isVisited: function (i, j) {\r\n    return ['visited', 'visited-animated'].includes(this.matrix[i][j].class);\r\n  },\r\n  isPath: function (i, j) {\r\n    return ['path', 'path-animated'].includes(this.matrix[i][j].class);\r\n  },\r\n  clearPath: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        if (\r\n          ['path', 'path-animated', 'visited', 'visited-animated'].includes(\r\n            cell.class\r\n          )\r\n        ) {\r\n          cell.update({\r\n            ...cell,\r\n            class: 'unvisited',\r\n          });\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  clearBoard: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        cell.update({\r\n          ...cell,\r\n          class: 'unvisited',\r\n          weighted: false,\r\n        });\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default gridOptions;\r\n","import React, { useState } from 'react';\r\nimport gridOptions from '../gridOptions';\r\nimport '../Assets/Styles/cell.css';\r\n\r\nconst Cell = ({ position: { i, j } }) => {\r\n  const [options, setOptions] = useState({\r\n    class: gridOptions.matrix[i][j].class,\r\n    weighted: gridOptions.matrix[i][j].weighted,\r\n    isSource: gridOptions.matrix[i][j].isSource,\r\n    isDestination: gridOptions.matrix[i][j].isDestination,\r\n  });\r\n  gridOptions.matrix[i][j].update = setOptions;\r\n  gridOptions.matrix[i][j].class = options.class;\r\n  gridOptions.matrix[i][j].weighted = options.weighted;\r\n  gridOptions.matrix[i][j].isSource = options.isSource;\r\n  gridOptions.matrix[i][j].isDestination = options.isDestination;\r\n\r\n  let classList = 'cell ' + (options.isSource ? 'source ' : '') + (options.isDestination ? 'destination ' : '');\r\n  if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged || !gridOptions.isAnimated) {\r\n    // if animation is turned off or source / destination are being dragged (and dropped), then set\r\n    // classes without \"-animated\" suffixes for rendering WITHOUT animation\r\n    classList += options.class + (options.weighted ? ' weight ' : '');\r\n  } else {\r\n    // else add \"-animated\" suffix to the end of the animated classes for rendering WITH animation\r\n    classList += `${options.class}-animated ` + (options.weighted ? 'weight-animated ' : '');\r\n  }\r\n\r\n  const handleMouseDown = (e) => {\r\n    if (e.button !== 0 || gridOptions.animationLaunched) return;\r\n\r\n    gridOptions.clicked = true;\r\n\r\n    if (gridOptions.matrix[i][j].isSource) {\r\n      gridOptions.isSourceDragged = true;\r\n    } else if (gridOptions.matrix[i][j].isDestination) {\r\n      gridOptions.isDestinationDragged = true;\r\n    } else {\r\n      if (!gridOptions.wpressed) {\r\n        setOptions({\r\n          ...options,\r\n          weighted: false,\r\n          class: options.class === 'wall' ? 'unvisited' : 'wall',\r\n        });\r\n      } else if (gridOptions.wpressed) {\r\n        setOptions({\r\n          ...options,\r\n          class: 'unvisited',\r\n          weighted: !options.weighted,\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleMouseOver = () => {\r\n    if (!gridOptions.clicked || gridOptions.matrix[i][j].isSource || gridOptions.matrix[i][j].isDestination) return;\r\n\r\n    if (gridOptions.isSourceDragged) {\r\n      const [prevSource_i, prevSource_j] = gridOptions.source;\r\n      const prevSourceOptions = gridOptions.matrix[prevSource_i][prevSource_j];\r\n\r\n      gridOptions.matrix[prevSource_i][prevSource_j].update({\r\n        ...prevSourceOptions,\r\n        isSource: false,\r\n      });\r\n      gridOptions.source = [i, j];\r\n\r\n      gridOptions.matrix[i][j].update({\r\n        ...options,\r\n        isSource: true,\r\n      });\r\n    } else if (gridOptions.isDestinationDragged) {\r\n      const [prevDestination_i, prevDestination_j] = gridOptions.destination;\r\n      const prevDestinationOptions = gridOptions.matrix[prevDestination_i][prevDestination_j];\r\n      gridOptions.matrix[prevDestination_i][prevDestination_j].update({\r\n        ...prevDestinationOptions,\r\n        isDestination: false,\r\n      });\r\n      gridOptions.destination = [i, j];\r\n      gridOptions.matrix[i][j].update({\r\n        ...options,\r\n        isDestination: true,\r\n      });\r\n    } else if (gridOptions.wpressed) {\r\n      // drawing a weighted node\r\n      setOptions({\r\n        ...options,\r\n        class: 'unvisited',\r\n        weighted: !options.weighted,\r\n      });\r\n    } else {\r\n      // drawing a wall\r\n      setOptions({\r\n        ...options,\r\n        weighted: false,\r\n        class: options.class === 'wall' ? 'unvisited' : 'wall',\r\n      });\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div\r\n      id={i + ',' + j}\r\n      onDragStart={(e) => {\r\n        e.preventDefault();\r\n      }}\r\n      className={classList}\r\n      onMouseDown={handleMouseDown}\r\n      onTouchStart={handleMouseDown}\r\n      onMouseOver={handleMouseOver}\r\n      onTouchMove={handleMouseOver}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default Cell;\r\n","import React from \"react\";\r\nimport Cell from \"./Cell\";\r\nimport \"../Assets/Styles/row.css\";\r\n\r\nconst Row = ({ i, columnCount }) => {\r\n  return (\r\n    <div className=\"row\">\r\n      {new Array(columnCount).fill().map((_, j) => (\r\n        <Cell position={{ i, j }} key={i + \",\" + j} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Row;\r\n","import React from 'react';\r\nimport Row from './Row';\r\nimport gridOptions from '../gridOptions';\r\nimport '../Assets/Styles/grid.css';\r\n\r\nconst Grid = ({ rowCount, columnCount, startNodePosition, endNodePosition }) => {\r\n  const rows = new Array(rowCount).fill().map((_, i) => <Row key={i.toString()} i={i} columnCount={columnCount} />);\r\n\r\n  gridOptions.matrix = new Array(rowCount);\r\n  for (let i = 0; i < rowCount; ++i) {\r\n    gridOptions.matrix[i] = new Array(columnCount);\r\n    for (let j = 0; j < columnCount; ++j) {\r\n      gridOptions.matrix[i][j] = { class: 'unvisited', weighted: false };\r\n    }\r\n  }\r\n  const [start_i, start_j] = startNodePosition;\r\n  const [end_i, end_j] = endNodePosition;\r\n  gridOptions.matrix[start_i][start_j].isSource = true;\r\n  gridOptions.matrix[end_i][end_j].isDestination = true;\r\n  gridOptions.source = [start_i, start_j];\r\n  gridOptions.destination = [end_i, end_j];\r\n\r\n  const handleMouseUp = async (e) => {\r\n    if (e.button !== 0) return;\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      if (gridOptions.isSourceDragged) {\r\n        const [i, j] = gridOptions.source;\r\n        gridOptions.matrix[i][j].update({\r\n          class: 'unvisited',\r\n          weighted: false,\r\n          isSource: true,\r\n          isDestination: false,\r\n        });\r\n        // console.log(gridOptions.matrix[i][j]);\r\n        // console.log(document.getElementById(i + ',' + j));\r\n      } else if (gridOptions.isDestinationDragged) {\r\n        const [i, j] = gridOptions.destination;\r\n        gridOptions.matrix[i][j].update({\r\n          class: 'unvisited',\r\n          weighted: false,\r\n          isSource: false,\r\n          isDestination: true,\r\n        });\r\n      }\r\n      if (gridOptions.instantAnimationOn) {\r\n        await gridOptions.chozenAlgorithmCallback();\r\n      }\r\n    }\r\n    gridOptions.isSourceDragged = false;\r\n    gridOptions.isDestinationDragged = false;\r\n    gridOptions.clicked = false;\r\n    gridOptions.wpressed = false;\r\n  };\r\n\r\n  const handleMouseLeave = async () => {\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      if (gridOptions.instantAnimationOn) {\r\n        await gridOptions.chozenAlgorithmCallback();\r\n      }\r\n    }\r\n    gridOptions.clicked = false;\r\n    gridOptions.wpressed = false;\r\n    gridOptions.isSourceDragged = false;\r\n    gridOptions.isDestinationDragged = false;\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        onDragStart={(e) => {\r\n          e.preventDefault();\r\n        }}\r\n        className=\"grid\"\r\n        onMouseUp={handleMouseUp}\r\n        onTouchEnd={handleMouseUp}\r\n        onMouseLeave={handleMouseLeave}\r\n        // ontouc\r\n      >\r\n        {rows}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","import gridOptions from \"../gridOptions\";\r\n\r\nexport async function runAlgorithm(name) {\r\n  if (!(name in searchingAlgorithms)) {\r\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\r\n  }\r\n  gridOptions.disableUserInteraction();\r\n  gridOptions.animationLaunched = true;\r\n  await searchingAlgorithms[name]();\r\n  gridOptions.animationLaunched = false;\r\n  gridOptions.enableUserInteraction();\r\n}\r\n\r\nconst animateCell = (state, i, j, time = gridOptions.delay) => {\r\n  return new Promise((resolve) => {\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      // when dragging either source or destination,update current cell immediately WITHOUT animation\r\n      gridOptions.matrix[i][j].update({\r\n        isSource: gridOptions.isSource(i, j),\r\n        isDestination: gridOptions.isDestination(i, j),\r\n        class: state,\r\n        weighted: gridOptions.isWeighted(i, j),\r\n      });\r\n      resolve();\r\n    } else {\r\n      setTimeout(() => {\r\n        gridOptions.matrix[i][j].update({\r\n          isSource: gridOptions.isSource(i, j),\r\n          isDestination: gridOptions.isDestination(i, j),\r\n          class: state,\r\n          weighted: gridOptions.isWeighted(i, j),\r\n        });\r\n        resolve();\r\n      }, time);\r\n    }\r\n  });\r\n};\r\n\r\nexport const searchingAlgorithms = {\r\n  bfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const mat = gridOptions.matrix;\r\n    const n = mat.length;\r\n    const m = mat[0].length;\r\n    const visited = new Array(n).fill().map((e) => new Array(m).fill(false));\r\n    const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n    visited[src[0]][src[1]] = true;\r\n    const queue = [{ position: [...src], distance: 0, path: [] }];\r\n    const addends = [\r\n      [0, 1],\r\n      [1, 0],\r\n      [0, -1],\r\n      [-1, 0],\r\n    ];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift();\r\n\r\n      const { position, distance, path } = current;\r\n      const [x, y] = position;\r\n      path.push([x, y]);\r\n\r\n      await animateCell(\"visited\", x, y);\r\n      visited[x][y] = true;\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        for (let [i, j] of path) {\r\n          await animateCell(\"path\", i, j);\r\n        }\r\n        break;\r\n      }\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          if (\r\n            !visited[newX][newY] &&\r\n            !gridOptions.isWall(newX, newY)\r\n            // gridOptions.matrix[newX][newY].class !== 'wall'\r\n          ) {\r\n            visited[newX][newY] = true;\r\n            queue.push({\r\n              position: [newX, newY],\r\n              distance: distance + 1,\r\n              path: [...path, [newX, newY]],\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  dfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n\r\n    gridOptions.clearPath();\r\n    await animateCell(\"unvisited\", src[0], src[1]);\r\n    await animateCell(\"unvisited\", src[0], src[1]);\r\n    const visited = new Set();\r\n    let foundPath = [];\r\n    async function search(current, path) {\r\n      const [x, y] = current;\r\n      if (gridOptions.isWall(x, y) || visited.has(x + \",\" + y)) return false;\r\n      path.push([x, y]);\r\n      await animateCell(\"visited\", x, y);\r\n      visited.add(x + \",\" + y);\r\n      // if ()) return false;\r\n      if (x === dst[0] && y === dst[1]) {\r\n        foundPath = path;\r\n        return true;\r\n      }\r\n      const addends = [\r\n        [-1, 0],\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n      ];\r\n      const n = gridOptions.matrix.length;\r\n      const m = gridOptions.matrix[0].length;\r\n      const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          let found = await search([newX, newY], [...path]);\r\n          if (found) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    await search(src, []);\r\n    for (let [i, j] of foundPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n  },\r\n  dijkstra: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n    const unvisited = new Set();\r\n    const prev = new Array(n);\r\n    const distances = new Array(n);\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      prev[i] = new Array(m).fill(null);\r\n      distances[i] = new Array(m).fill(Infinity);\r\n      for (let j = 0; j < m; ++j) {\r\n        unvisited.add(i + \",\" + j);\r\n      }\r\n    }\r\n\r\n    const stringify = (i, j) => i + \",\" + j;\r\n    const indexify = (vertex) => (vertex ? vertex.split(\",\").map((idx) => Number(idx)) : [-1, -1]);\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"unvisited\" set and returns it\r\n      let minDistance = Infinity;\r\n      let minDistanceVertex = null;\r\n      const verticies = unvisited.keys();\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n        if (distances[i][j] < minDistance) {\r\n          minDistance = distances[i][j];\r\n          minDistanceVertex = v;\r\n        }\r\n      }\r\n      if (!minDistanceVertex) {\r\n        minDistanceVertex = verticies[0];\r\n      }\r\n\r\n      unvisited.delete(minDistanceVertex);\r\n      return indexify(minDistanceVertex);\r\n    };\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && !gridOptions.isWall(newX, newY)) {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n\r\n      return neighbors;\r\n    };\r\n\r\n    distances[src[0]][src[1]] = 0;\r\n\r\n    while (unvisited.size > 0) {\r\n      const [x, y] = extractMin();\r\n      if (x === -1 || y === -1) {\r\n        // there is no path\r\n        break;\r\n      }\r\n      await animateCell(\"visited\", x, y);\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // found the shortest path\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n\r\n        let v = stringify(i, j);\r\n        if (unvisited.has(v)) {\r\n          const alt = distances[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n          if (alt < distances[i][j]) {\r\n            distances[i][j] = alt;\r\n            prev[i][j] = [x, y];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let shortestPath = [];\r\n    if (prev[dst[0]][dst[1]]) {\r\n      let current = dst;\r\n      while (current) {\r\n        shortestPath.push(current);\r\n        current = prev[current[0]][current[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse();\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n  },\r\n\r\n  astar: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.disableUserInteraction();\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n\r\n    const openSet = new Set();\r\n    const prev = new Array(n);\r\n    const gScore = new Array(n);\r\n    const fScore = new Array(n);\r\n\r\n    const getHeruistic = (i, j) => {\r\n      return Math.abs(i - dst[0]) + Math.abs(j - dst[1]);\r\n    };\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      gScore[i] = new Array(m).fill(Infinity);\r\n      fScore[i] = new Array(m).fill(Infinity);\r\n      prev[i] = new Array(m);\r\n      for (let j = 0; j < m; ++j) {\r\n        prev[i][j] = null;\r\n      }\r\n    }\r\n\r\n    fScore[src[0]][src[1]] = getHeruistic(src[0], src[1]);\r\n    openSet.add(src[0] + \",\" + src[1]);\r\n    gScore[src[0]][src[1]] = 0;\r\n\r\n    const stringify = (i, j) => i + \",\" + j; // returns hash value for two indicies of the vertex\r\n    const indexify = (vertex) => vertex.split(\",\").map((idx) => Number(idx)); // returns two indicies from hash value of the vertex\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"openSet\" and returns it\r\n      let minFScore = Infinity;\r\n      let minFScoreVertex = null;\r\n      const verticies = openSet.keys();\r\n\r\n      // find the vertex in openSet with minimum fScore\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n\r\n        if (fScore[i][j] < minFScore) {\r\n          minFScore = fScore[i][j];\r\n          minFScoreVertex = v;\r\n        } else if (fScore[i][j] === minFScore) {\r\n          // if fscores are equal, choose a vertex with lower herustic score\r\n          let [x, y] = indexify(minFScoreVertex);\r\n          if (getHeruistic(i, j) < getHeruistic(x, y)) {\r\n            minFScore = fScore[i][j];\r\n            minFScoreVertex = v;\r\n          }\r\n        }\r\n      }\r\n\r\n      openSet.delete(minFScoreVertex);\r\n      return indexify(minFScoreVertex);\r\n    };\r\n\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      // addendsd for possible directions we can move from v\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n\r\n        // validating possible neighbor coordinates\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && matrix[newX][newY].class !== \"wall\") {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n      return neighbors;\r\n    };\r\n\r\n    while (openSet.size > 0) {\r\n      const [x, y] = extractMin(); // extract the node with minimal fScore in openSet and remove it from the set\r\n\r\n      await animateCell(\"visited\", x, y);\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // prev[x][y].push([x, y]);\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n        const tentative_gScore = gScore[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n        // await sleepPromise('visited', i, j);\r\n        if (tentative_gScore < gScore[i][j]) {\r\n          gScore[i][j] = tentative_gScore;\r\n          prev[i][j] = [x, y];\r\n          fScore[i][j] = tentative_gScore + getHeruistic(i, j);\r\n          openSet.add(stringify(i, j));\r\n        }\r\n      }\r\n    }\r\n    const shortestPath = [];\r\n\r\n    if (prev[dst[0]][dst[1]]) {\r\n      // if the path found, than construct the shortestPath via backtracking from the destination node\r\n      let currentNode = dst;\r\n      while (currentNode) {\r\n        shortestPath.push(currentNode);\r\n        currentNode = prev[currentNode[0]][currentNode[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse(); // reversing the path to get it in right order (from source to destination)\r\n\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n    gridOptions.enableUserInteraction();\r\n  },\r\n};\r\n","import gridOptions from \"../gridOptions\";\r\n\r\nconst animateCell = (state, i, j, time = gridOptions.delay) => {\r\n  return new Promise((resolve) => {\r\n    if (state === \"wall\" && (gridOptions.isSource(i, j) || gridOptions.isDestination(i, j))) {\r\n      resolve();\r\n    } else {\r\n      setTimeout(() => {\r\n        gridOptions.matrix[i][j].update({\r\n          isSource: gridOptions.isSource(i, j),\r\n          isDestination: gridOptions.isDestination(i, j),\r\n          class: state,\r\n          weighted: gridOptions.isWeighted(i, j),\r\n        });\r\n        resolve();\r\n      }, time);\r\n    }\r\n  });\r\n};\r\n\r\nexport async function runMazeAlgorithm(name) {\r\n  if (!(name in mazeAlgorithms)) {\r\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\r\n  }\r\n  gridOptions.disableUserInteraction();\r\n  gridOptions.animationLaunched = true;\r\n  await mazeAlgorithms[name]();\r\n  gridOptions.animationLaunched = false;\r\n  gridOptions.enableUserInteraction();\r\n}\r\n\r\nconst mazeAlgorithms = {\r\n  recursiveDivision: async () => {\r\n    const randInt = (min, max) => {\r\n      return Math.floor(Math.random() * (max - min + 1) + min);\r\n    };\r\n\r\n    const chooseOrientation = (height, width) => {\r\n      let orientation = \"\";\r\n      if (height > width) {\r\n        orientation = \"Horizontal\";\r\n      } else if (height < width) {\r\n        orientation = \"Vertical\";\r\n      } else {\r\n        orientation = Math.random() <= 0.5 ? \"Horizontal\" : \"Vertical\";\r\n      }\r\n      return orientation;\r\n    };\r\n    const randWallIndex = (from, to) => {\r\n      let wallIndex = -1;\r\n      const indicies = [];\r\n      for (let idx = from; idx <= to; ++idx) {\r\n        if (idx % 2 !== 0) indicies.push(idx);\r\n      }\r\n      if (indicies.length > 0) {\r\n        let randIndex = randInt(0, indicies.length - 1);\r\n        wallIndex = indicies[randIndex];\r\n        // wallIndex = indicies[Math.floor(indicies.length / 2)];\r\n      }\r\n\r\n      return wallIndex;\r\n    };\r\n\r\n    const randHoleIndex = (from, to) => {\r\n      let holeIndex = -1;\r\n\r\n      const indicies = [];\r\n\r\n      for (let col = from; col <= to; ++col) {\r\n        if (col % 2 === 0) indicies.push(col);\r\n      }\r\n      if (indicies.length > 0) {\r\n        let randIndex = randInt(0, indicies.length - 1);\r\n        holeIndex = indicies[randIndex];\r\n        // holeIndex = indicies[Math.floor(indicies.length / 2)];\r\n      }\r\n\r\n      return holeIndex;\r\n    };\r\n\r\n    const divide = async (i, height, j, width) => {\r\n      if (width <= 2 || height <= 2) {\r\n        return;\r\n      }\r\n\r\n      const orientation = chooseOrientation(height, width);\r\n\r\n      if (orientation === \"Horizontal\") {\r\n        const wallIndex = randWallIndex(i + 1, i + height - 2);\r\n        if (wallIndex === -1) return;\r\n\r\n        const holeIndex = randHoleIndex(j, j + width - 1);\r\n        if (holeIndex === -1) return;\r\n\r\n        for (let col = j; col < j + width; ++col) {\r\n          if (col !== holeIndex) {\r\n            await animateCell(\"wall\", wallIndex, col);\r\n          }\r\n        }\r\n\r\n        await divide(i, wallIndex - i, j, width);\r\n        await divide(wallIndex + 1, i + height - wallIndex - 1, j, width);\r\n      } else if (orientation === \"Vertical\") {\r\n        let wallIndex = randWallIndex(j + 1, j + width - 2);\r\n        if (wallIndex === -1) return;\r\n\r\n        const holeIndex = randHoleIndex(i, i + height - 1);\r\n        if (holeIndex === -1) return;\r\n        for (let row = i; row < i + height; ++row) {\r\n          if (row !== holeIndex) {\r\n            await animateCell(\"wall\", row, wallIndex);\r\n          }\r\n        }\r\n        await divide(i, height, j, wallIndex - j);\r\n        await divide(i, height, wallIndex + 1, j + width - wallIndex - 1);\r\n      }\r\n    };\r\n    const [n, m] = gridOptions.getSize();\r\n    await divide(0, n, 0, m);\r\n\r\n    // check if source or destination are disconnected from the grid (are surrounded by walls),\r\n    //    if so, randomly remove one of the walls\r\n\r\n    const src = gridOptions.source;\r\n    const sourceNeighbors = [\r\n      [src[0] + 1, src[1]],\r\n      [src[0] - 1, src[1]],\r\n      [src[0], src[1] + 1],\r\n      [src[0], src[1] - 1],\r\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\r\n\r\n    if (sourceNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\r\n      const randIndex = randInt(0, sourceNeighbors.length - 1);\r\n      await animateCell(\"unvisited\", ...sourceNeighbors[randIndex]);\r\n    }\r\n\r\n    const dst = gridOptions.destination;\r\n    const destinationNeighbors = [\r\n      [dst[0] + 1, dst[1]],\r\n      [dst[0] - 1, dst[1]],\r\n      [dst[0], dst[1] + 1],\r\n      [dst[0], dst[1] - 1],\r\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\r\n\r\n    if (destinationNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\r\n      const randIndex = randInt(0, destinationNeighbors.length - 1);\r\n      await animateCell(\"unvisited\", ...destinationNeighbors[randIndex]);\r\n    }\r\n  },\r\n  randomizedDFS: async () => {\r\n    const [n, m] = gridOptions.getSize();\r\n    let visited = new Set();\r\n\r\n    const stringify = ([x, y]) => x + \",\" + y;\r\n    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\r\n\r\n    const isVisited = ([x, y]) => {\r\n      return visited.has(x + \",\" + y);\r\n    };\r\n\r\n    const getNeigborsWithDistance = (x, y, distance) => {\r\n      const neighbors = [];\r\n      let addends = [\r\n        [0, distance],\r\n        [distance, 0],\r\n        [0, -distance],\r\n        [-distance, 0],\r\n      ];\r\n\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m) {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n      // randomly shuffle with Fisher–Yates algorithm\r\n      const shuffled = [];\r\n      while (neighbors.length > 0) {\r\n        const l = neighbors.length - 1;\r\n        let randIndex = randInt(0, l);\r\n        shuffled.push(neighbors[randIndex]);\r\n\r\n        const temp = neighbors[randIndex];\r\n        neighbors[randIndex] = neighbors[l];\r\n        neighbors[l] = temp;\r\n\r\n        neighbors.pop();\r\n      }\r\n\r\n      return shuffled;\r\n    };\r\n\r\n    const getNeigbors = (x, y) => {\r\n      return getNeigborsWithDistance(x, y, 2);\r\n    };\r\n\r\n    const getHoleNeighbors = (x, y) => {\r\n      return getNeigborsWithDistance(x, y, 1);\r\n    };\r\n\r\n    const dfs = async (vertex) => {\r\n      const [i, j] = vertex;\r\n      if (isVisited(vertex)) return;\r\n\r\n      visited.add(stringify(vertex));\r\n\r\n      const neighbors = getNeigbors(i, j);\r\n      for (let neighbor of neighbors) {\r\n        if (!isVisited(neighbor)) {\r\n          const wallI = (i + neighbor[0]) / 2;\r\n          const wallJ = (j + neighbor[1]) / 2;\r\n          if (!gridOptions.isWall(wallI, wallJ)) await animateCell(\"wall\", wallI, wallJ);\r\n          if (i === wallI) {\r\n            wallI - 1 >= 0 && !gridOptions.isWall(wallI - 1, wallJ) && (await animateCell(\"wall\", wallI - 1, wallJ));\r\n            wallI + 1 < n && !gridOptions.isWall(wallI + 1, wallJ) && (await animateCell(\"wall\", wallI + 1, wallJ));\r\n          } else if (j === wallJ) {\r\n            wallJ - 1 >= 0 && !gridOptions.isWall(wallI, wallJ - 1) && (await animateCell(\"wall\", wallI, wallJ - 1));\r\n            wallJ + 1 < m && !gridOptions.isWall(wallI, wallJ + 1) && (await animateCell(\"wall\", wallI, wallJ + 1));\r\n          }\r\n        }\r\n      }\r\n      for (let neighbor of neighbors) {\r\n        if (!isVisited(neighbor)) {\r\n          const holeI = (i + neighbor[0]) / 2;\r\n          const holeJ = (j + neighbor[1]) / 2;\r\n\r\n          const holeNeighbors = getHoleNeighbors(holeI, holeJ);\r\n          for (let holeNeighbor of holeNeighbors) {\r\n            if (\r\n              !gridOptions.isWall(holeNeighbor[0], holeNeighbor[1]) &&\r\n              !isVisited(holeNeighbor) &&\r\n              (neighbor[0] !== holeNeighbor[0] || neighbor[1] !== holeNeighbor[1])\r\n            ) {\r\n              await animateCell(\"wall\", holeNeighbor[0], holeNeighbor[1]);\r\n            }\r\n          }\r\n          await animateCell(\"unvisited\", holeI, holeJ, 0);\r\n          visited.add(stringify([holeI, holeJ]));\r\n          await dfs(neighbor);\r\n        }\r\n      }\r\n    };\r\n\r\n    await dfs([0, 0]);\r\n\r\n    // adding walls to unreachable cells (which are considered to be walls)\r\n    // for (let i = 1; i < n; i += 2) {\r\n    //   for (let j = 1; j < m; j += 2) {\r\n    //     if (\r\n    //       gridOptions.isUnvisited(i, j) &&\r\n    //       getHoleNeighbors(i, j).every(([row, col]) => {\r\n    //         return gridOptions.isWall(row, col);\r\n    //       })\r\n    //     ) {\r\n    //       await animateCell(\"wall\", i, j);\r\n    //     }\r\n    //   }\r\n    // }\r\n  },\r\n\r\n  binaryTree: async () => {\r\n    const [n, m] = gridOptions.getSize();\r\n    for (let i = 2; i < n; i += 2) {\r\n      for (let j = 2; j < m; j += 2) {\r\n        await animateCell(\"unvisited\", i, j);\r\n        // randomly chooze connection direciton either north or west\r\n        if (Math.random() <= 0.5) {\r\n          const passageI = i - 1;\r\n          const passageJ = j;\r\n          if (passageI < n && passageJ < m) {\r\n            await animateCell(\"wall\", i, passageJ - 1);\r\n            await animateCell(\"wall\", passageI, passageJ - 1);\r\n          }\r\n        } else {\r\n          const passageI = i;\r\n          const passageJ = j - 1;\r\n          if (passageI >= 1 && passageI < n && passageJ >= 0 && passageJ < m) {\r\n            await animateCell(\"wall\", passageI - 1, j);\r\n            await animateCell(\"wall\", passageI - 1, passageJ);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n  primsRandomizedAlgorithm: async () => {\r\n    const [n, m] = gridOptions.getSize();\r\n    const visited = new Set();\r\n    let unvisited = new Set();\r\n    const middleRow = Math.floor(n / 2) - (Math.floor(n / 2) % 2);\r\n    const middleCol = Math.floor(m / 2) - (Math.floor(m / 2) % 2);\r\n    console.log({ middleRow, middleCol });\r\n    unvisited.add(`${middleRow},${middleCol}`);\r\n    // throw new Error(\"xxx\");\r\n\r\n    const randInt = (min, max) => {\r\n      return Math.floor(Math.random() * (max - min + 1) + min);\r\n    };\r\n\r\n    const isVisited = (i, j) => visited.has(i + \",\" + j);\r\n\r\n    const extractRandomVertexFromUnvisitedSet = () => {\r\n      const randIndex = randInt(0, unvisited.size - 1);\r\n      const randVertex = Array.from(unvisited.keys())[randIndex];\r\n      unvisited.delete(randVertex);\r\n      return randVertex;\r\n    };\r\n    const getVisitedNeigbors = (i, j) => {\r\n      const neighbors = [\r\n        [i, j + 2],\r\n        [i + 2, j],\r\n        [i, j - 2],\r\n        [i - 2, j],\r\n      ];\r\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && isVisited(r, c));\r\n    };\r\n    const getWallNeighbors = (i, j) => {\r\n      const neighbors = [\r\n        [i, j + 1],\r\n        [i + 1, j],\r\n        [i, j - 1],\r\n        [i - 1, j],\r\n        [i + 1, j + 1],\r\n        [i + 1, j - 1],\r\n        [i - 1, j - 1],\r\n        [i - 1, j + 1],\r\n      ];\r\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c));\r\n    };\r\n\r\n    const getUnvisitedNeigbors = (i, j) => {\r\n      const neighbors = [\r\n        [i, j + 2],\r\n        [i + 2, j],\r\n        [i, j - 2],\r\n        [i - 2, j],\r\n      ];\r\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c));\r\n    };\r\n    while (unvisited.size > 0) {\r\n      const vertex = extractRandomVertexFromUnvisitedSet();\r\n      const [vi, vj] = vertex.split(\",\").map((e) => Number(e));\r\n      animateCell(\"unvisited\", vi, vj, 0);\r\n      for (let [i, j] of getWallNeighbors(vi, vj)) {\r\n        if (!gridOptions.isWall(i, j)) await animateCell(\"wall\", i, j);\r\n      }\r\n      visited.add(vertex);\r\n      const visitedNeigbors = getVisitedNeigbors(vi, vj);\r\n      if (visitedNeigbors.length > 0) {\r\n        const randIndex = randInt(0, visitedNeigbors.length - 1);\r\n        const randVertex = visitedNeigbors[randIndex];\r\n        animateCell(\"unvisited\", randVertex[0], randVertex[1], 0);\r\n        animateCell(\"unvisited\", (randVertex[0] + vi) / 2, (randVertex[1] + vj) / 2, 0);\r\n      }\r\n\r\n      const unvisitedNeigbors = getUnvisitedNeigbors(vi, vj);\r\n      unvisitedNeigbors.forEach(([i, j]) => {\r\n        unvisited.add(i + \",\" + j);\r\n      });\r\n    }\r\n  },\r\n};\r\n","import React, { useEffect } from \"react\";\r\nimport { searchingAlgorithms, runAlgorithm } from \"../Algorithms/searchingAlgorithms\";\r\nimport { runMazeAlgorithm } from \"../Algorithms/mazeAlgorithms\";\r\nimport gridOptions from \"../gridOptions\";\r\nimport \"../Assets/Styles/controlPanel.css\";\r\n\r\nconst ControlPanel = () => {\r\n  useEffect(() => {\r\n    document.getElementById(\"speedInput\").value = 200;\r\n    document.getElementById(\"isAnimatedCheckBox\").checked = true;\r\n    document.getElementById(\"instantAnimationCheckbox\").checked = true;\r\n    gridOptions.delay = 0;\r\n\r\n    document.body.addEventListener(\"keydown\", (e) => {\r\n      if (e.key === \"w\") {\r\n        gridOptions.wpressed = true;\r\n        gridOptions.wallToggleON = false;\r\n      }\r\n    });\r\n    document.body.addEventListener(\"keyup\", (e) => {\r\n      if (e.key === \"w\") {\r\n        gridOptions.wpressed = false;\r\n      }\r\n    });\r\n  });\r\n  return (\r\n    <div id=\"controlPanel\">\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Searching Algorithms</label>\r\n        <button\r\n          id=\"bfsBtn\"\r\n          onClick={async () => {\r\n            gridOptions.chozenAlgorithmCallback = searchingAlgorithms.bfs;\r\n            await runAlgorithm(\"bfs\");\r\n          }}\r\n        >\r\n          Breadth First Search\r\n        </button>\r\n\r\n        <button\r\n          id=\"dfsBtn\"\r\n          onClick={async () => {\r\n            gridOptions.chozenAlgorithmCallback = searchingAlgorithms.dfs;\r\n            await runAlgorithm(\"dfs\");\r\n          }}\r\n        >\r\n          Depth First Search\r\n        </button>\r\n        <button\r\n          id=\"dijkstraBtn\"\r\n          onClick={async () => {\r\n            gridOptions.chozenAlgorithmCallback = searchingAlgorithms.dijkstra;\r\n            await runAlgorithm(\"dijkstra\");\r\n          }}\r\n        >\r\n          Dijkstra's Algorithm\r\n        </button>\r\n        <button\r\n          id=\"astarBtn\"\r\n          onClick={async () => {\r\n            gridOptions.chozenAlgorithmCallback = searchingAlgorithms.astar;\r\n            await runAlgorithm(\"astar\");\r\n          }}\r\n        >\r\n          A* Algorithm\r\n        </button>\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Maze Algorithms</label>\r\n        <button\r\n          id=\"recursiveDivisionBtn\"\r\n          onClick={async () => {\r\n            gridOptions.clearBoard();\r\n            await runMazeAlgorithm(\"recursiveDivision\");\r\n          }}\r\n        >\r\n          Recursive Division\r\n        </button>\r\n\r\n        <button\r\n          id=\"randomizedDFSBtn\"\r\n          onClick={async () => {\r\n            gridOptions.clearBoard();\r\n            await runMazeAlgorithm(\"randomizedDFS\");\r\n          }}\r\n        >\r\n          Randomized DFS\r\n        </button>\r\n        <button\r\n          id=\"binaryTreeBtn\"\r\n          onClick={async () => {\r\n            gridOptions.clearBoard();\r\n            await runMazeAlgorithm(\"binaryTree\");\r\n          }}\r\n        >\r\n          Binary Tree\r\n        </button>\r\n        <button\r\n          id=\"primsRandomizedAlgorithmBtn\"\r\n          onClick={async () => {\r\n            gridOptions.clearBoard();\r\n            await runMazeAlgorithm(\"primsRandomizedAlgorithm\");\r\n          }}\r\n        >\r\n          Prim's randomized\r\n        </button>\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Grid options</label>\r\n        <button\r\n          id=\"clearBoardBtn\"\r\n          onClick={async () => {\r\n            gridOptions.clearBoard();\r\n          }}\r\n        >\r\n          Clear Board\r\n        </button>\r\n        <button\r\n          id=\"clearPathBtn\"\r\n          onClick={async () => {\r\n            gridOptions.clearPath();\r\n          }}\r\n        >\r\n          Clear Path\r\n        </button>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"speedInput\">Speed:</label>\r\n          <input\r\n            id=\"speedInput\"\r\n            type=\"range\"\r\n            min=\"0\"\r\n            max=\"200\"\r\n            onChange={(e) => {\r\n              gridOptions.delay = 200 - Number(e.target.value);\r\n            }}\r\n          />\r\n        </div>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"isAnimatedCheckBox\">Animated: </label>\r\n          <input\r\n            onChange={() => {\r\n              gridOptions.isAnimated = !gridOptions.isAnimated;\r\n            }}\r\n            id=\"isAnimatedCheckBox\"\r\n            type=\"checkbox\"\r\n          />\r\n        </div>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"instantAnimationCheckbox\">Insant Animation:</label>\r\n          <input\r\n            onChange={() => {\r\n              gridOptions.instantAnimationOn = !gridOptions.instantAnimationOn;\r\n            }}\r\n            id=\"instantAnimationCheckbox\"\r\n            type=\"checkbox\"\r\n          />\r\n        </div>\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Icons</label>\r\n        <div className=\"inline-block\">\r\n          <img src={require(\"../Assets/Icons/source.png\")} alt=\"destination.png\" />\r\n          <label>Source node</label>\r\n          <img src={require(\"../Assets/Icons/destination.png\")} alt=\"source.png\" />\r\n          <label>Destination node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={require(\"../Assets/Icons/wall.png\")} alt=\"wall.png\" />\r\n          <label>Wall node</label>\r\n          <img src={require(\"../Assets/Icons/weight.png\")} alt=\"source.png\" />\r\n          <label>Weighted node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={require(\"../Assets/Icons/unvisited.png\")} alt=\"unvisited.png\" />\r\n          <label>Unvisited node</label>\r\n          <img src={require(\"../Assets/Icons/visited.png\")} alt=\"visited.png\" />\r\n          <label>Visited node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={require(\"../Assets/Icons/path.png\")} alt=\"path.png\" />\r\n          <label>Path node</label>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ControlPanel;\r\n","import React, { useEffect } from \"react\";\r\nimport Grid from \"./Grid\";\r\nimport ControlPanel from \"./ControlPanel\";\r\nimport \"../Assets/Styles/app.css\";\r\n\r\nconst App = () => {\r\n  useEffect(() => {\r\n    document.title = \"Pathfinding & Maze Generating visualizer\";\r\n  });\r\n  return (\r\n    <div className=\"flex-box\">\r\n      <ControlPanel />\r\n      <Grid rowCount={25} columnCount={55} startNodePosition={[11, 10]} endNodePosition={[11, 40]} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport App from \"./Components/App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}